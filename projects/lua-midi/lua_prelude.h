/* ============================================================================
 * Lua prelude - constants and helper functions
 * Generated from prelude.lua by scripts/prelude2c.py
 * ============================================================================ */

static const char *LUA_PRELUDE_MODULE =
"-- Pitch constants\n"
"for oct = 0, 8 do\n"
"  midi['c'..oct] = 12 + oct * 12\n"
"  midi['cs'..oct] = 13 + oct * 12\n"
"  midi['d'..oct] = 14 + oct * 12\n"
"  midi['ds'..oct] = 15 + oct * 12\n"
"  midi['e'..oct] = 16 + oct * 12\n"
"  midi['f'..oct] = 17 + oct * 12\n"
"  midi['fs'..oct] = 18 + oct * 12\n"
"  midi['g'..oct] = 19 + oct * 12\n"
"  midi['gs'..oct] = 20 + oct * 12\n"
"  midi['a'..oct] = 21 + oct * 12\n"
"  midi['as'..oct] = 22 + oct * 12\n"
"  midi['b'..oct] = 23 + oct * 12\n"
"  -- Flat aliases\n"
"  midi['db'..oct] = 13 + oct * 12\n"
"  midi['eb'..oct] = 15 + oct * 12\n"
"  midi['gb'..oct] = 18 + oct * 12\n"
"  midi['ab'..oct] = 20 + oct * 12\n"
"  midi['bb'..oct] = 22 + oct * 12\n"
"end\n"
"\n"
"-- Dynamics (velocity values)\n"
"midi.ppp = 16\n"
"midi.pp = 33\n"
"midi.p = 49\n"
"midi.mp = 64\n"
"midi.mf = 80\n"
"midi.f = 96\n"
"midi.ff = 112\n"
"midi.fff = 127\n"
"\n"
"-- Duration constants (ms at 120 BPM)\n"
"midi.whole = 2000\n"
"midi.half = 1000\n"
"midi.quarter = 500\n"
"midi.eighth = 250\n"
"midi.sixteenth = 125\n"
"\n"
"-- Tempo state\n"
"midi._tempo = 120\n"
"\n"
"function midi.set_tempo(bpm)\n"
"  midi._tempo = bpm\n"
"  local q = math.floor(60000 / bpm)\n"
"  midi.quarter = q\n"
"  midi.whole = q * 4\n"
"  midi.half = q * 2\n"
"  midi.eighth = math.floor(q / 2)\n"
"  midi.sixteenth = math.floor(q / 4)\n"
"end\n"
"\n"
"function midi.get_tempo()\n"
"  return midi._tempo\n"
"end\n"
"\n"
"function midi.bpm(tempo)\n"
"  return math.floor(60000 / tempo)\n"
"end\n"
"\n"
"function midi.dotted(dur)\n"
"  return math.floor(dur * 1.5)\n"
"end\n"
"\n"
"function midi.rest(dur)\n"
"  midi.sleep(dur or midi.quarter)\n"
"end\n"
"\n"
"-- Scale intervals (semitones from root)\n"
"midi.scales = {\n"
"  -- Diatonic modes\n"
"  major = {0, 2, 4, 5, 7, 9, 11},\n"
"  ionian = {0, 2, 4, 5, 7, 9, 11},\n"
"  dorian = {0, 2, 3, 5, 7, 9, 10},\n"
"  phrygian = {0, 1, 3, 5, 7, 8, 10},\n"
"  lydian = {0, 2, 4, 6, 7, 9, 11},\n"
"  mixolydian = {0, 2, 4, 5, 7, 9, 10},\n"
"  minor = {0, 2, 3, 5, 7, 8, 10},\n"
"  aeolian = {0, 2, 3, 5, 7, 8, 10},\n"
"  locrian = {0, 1, 3, 5, 6, 8, 10},\n"
"\n"
"  -- Other minor scales\n"
"  harmonic_minor = {0, 2, 3, 5, 7, 8, 11},\n"
"  melodic_minor = {0, 2, 3, 5, 7, 9, 11},\n"
"\n"
"  -- Pentatonic\n"
"  pentatonic = {0, 2, 4, 7, 9},\n"
"  pentatonic_major = {0, 2, 4, 7, 9},\n"
"  pentatonic_minor = {0, 3, 5, 7, 10},\n"
"\n"
"  -- Blues\n"
"  blues = {0, 3, 5, 6, 7, 10},\n"
"\n"
"  -- Symmetric\n"
"  whole_tone = {0, 2, 4, 6, 8, 10},\n"
"  chromatic = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},\n"
"  diminished_hw = {0, 1, 3, 4, 6, 7, 9, 10},\n"
"  diminished_wh = {0, 2, 3, 5, 6, 8, 9, 11},\n"
"  augmented = {0, 3, 4, 7, 8, 11},\n"
"\n"
"  -- Bebop\n"
"  bebop_dominant = {0, 2, 4, 5, 7, 9, 10, 11},\n"
"  bebop_major = {0, 2, 4, 5, 7, 8, 9, 11},\n"
"  bebop_minor = {0, 2, 3, 5, 7, 8, 9, 10},\n"
"\n"
"  -- Exotic/World\n"
"  hungarian_minor = {0, 2, 3, 6, 7, 8, 11},\n"
"  double_harmonic = {0, 1, 4, 5, 7, 8, 11},\n"
"  neapolitan_major = {0, 1, 3, 5, 7, 9, 11},\n"
"  neapolitan_minor = {0, 1, 3, 5, 7, 8, 11},\n"
"  phrygian_dominant = {0, 1, 4, 5, 7, 8, 10},\n"
"  persian = {0, 1, 4, 5, 6, 8, 11},\n"
"  altered = {0, 1, 3, 4, 6, 8, 10},\n"
"  enigmatic = {0, 1, 4, 6, 8, 10, 11},\n"
"\n"
"  -- Japanese\n"
"  hirajoshi = {0, 2, 3, 7, 8},\n"
"  in_sen = {0, 1, 5, 7, 10},\n"
"  iwato = {0, 1, 5, 6, 10},\n"
"  kumoi = {0, 2, 3, 7, 9},\n"
"\n"
"  -- Other world scales\n"
"  egyptian = {0, 2, 5, 7, 10},\n"
"  romanian_minor = {0, 2, 3, 6, 7, 9, 10},\n"
"  spanish_8_tone = {0, 1, 3, 4, 5, 6, 8, 10},\n"
"\n"
"  -- Arabic Maqamat (12-TET approximations)\n"
"  maqam_hijaz = {0, 1, 4, 5, 7, 8, 10},\n"
"  maqam_nahawand = {0, 2, 3, 5, 7, 8, 11},\n"
"  maqam_nikriz = {0, 2, 3, 6, 7, 9, 10},\n"
"  maqam_athar_kurd = {0, 1, 3, 5, 6, 8, 10},\n"
"  maqam_shawq_afza = {0, 2, 3, 6, 7, 9, 11},\n"
"  maqam_jiharkah = {0, 2, 4, 5, 7, 9, 10},\n"
"\n"
"  -- Indian Ragas (12-TET approximations)\n"
"  raga_bhairav = {0, 1, 4, 5, 7, 8, 11},\n"
"  raga_todi = {0, 1, 3, 6, 7, 8, 11},\n"
"  raga_marwa = {0, 1, 4, 6, 7, 9, 11},\n"
"  raga_purvi = {0, 1, 4, 6, 7, 8, 11},\n"
"  raga_charukeshi = {0, 2, 4, 5, 7, 8, 10},\n"
"  raga_asavari = {0, 2, 3, 5, 7, 8, 10},\n"
"  raga_bilawal = {0, 2, 4, 5, 7, 9, 11},\n"
"  raga_khamaj = {0, 2, 4, 5, 7, 9, 10},\n"
"  raga_kalyan = {0, 2, 4, 6, 7, 9, 11},\n"
"  raga_bhimpalasi = {0, 3, 5, 7, 10},\n"
"  raga_darbari = {0, 2, 3, 5, 7, 8, 9},\n"
"}\n"
"\n"
"-- Microtonal scales (cents-based, for use with pitch_bend)\n"
"midi.scales_cents = {\n"
"  -- Arabic Maqamat with quarter tones\n"
"  maqam_bayati = {0, 150, 300, 500, 700, 800, 1000},\n"
"  maqam_rast = {0, 200, 350, 500, 700, 900, 1050},\n"
"  maqam_saba = {0, 150, 300, 400, 500, 700, 800},\n"
"  maqam_sikah = {0, 150, 350, 500, 650, 850, 1000},\n"
"  maqam_huzam = {0, 150, 350, 500, 700, 850, 1050},\n"
"  maqam_iraq = {0, 150, 350, 500, 700, 850, 1000},\n"
"  maqam_bastanikar = {0, 150, 350, 500, 700, 800, 1000},\n"
"\n"
"  -- Turkish Makamlar\n"
"  makam_ussak = {0, 150, 300, 500, 700, 800, 1000},\n"
"  makam_huseyni = {0, 150, 300, 500, 700, 900, 1000},\n"
"\n"
"  -- Indian 22-Shruti scale\n"
"  shruti = {0, 90, 112, 182, 204, 294, 316, 386, 408, 498, 520, 590,\n"
"            612, 702, 792, 814, 884, 906, 996, 1018, 1088, 1110},\n"
"}\n"
"\n"
"-- Helper: convert cents interval to note + bend\n"
"function midi.cents_to_note(root, cents)\n"
"  local semitones = math.floor(cents / 100)\n"
"  local bend_cents = cents % 100\n"
"  if bend_cents > 50 then\n"
"    semitones = semitones + 1\n"
"    bend_cents = bend_cents - 100\n"
"  end\n"
"  return root + semitones, bend_cents\n"
"end\n"
"\n"
"-- Helper: build scale with name lookup\n"
"function scale(root, name)\n"
"  local intervals = midi.scales[name]\n"
"  if not intervals then\n"
"    error('Unknown scale: ' .. tostring(name))\n"
"  end\n"
"  return midi.build_scale(root, intervals)\n"
"end\n"
"\n"
"-- Helper: get scale degree with name lookup\n"
"function degree(root, name, deg)\n"
"  local intervals = midi.scales[name]\n"
"  if not intervals then\n"
"    error('Unknown scale: ' .. tostring(name))\n"
"  end\n"
"  return midi.scale_degree(root, intervals, deg)\n"
"end\n"
"\n"
"-- Helper: check if pitch is in named scale\n"
"function in_scale(pitch, root, name)\n"
"  local intervals = midi.scales[name]\n"
"  if not intervals then\n"
"    error('Unknown scale: ' .. tostring(name))\n"
"  end\n"
"  return midi.in_scale(pitch, root, intervals)\n"
"end\n"
"\n"
"-- Helper: quantize to named scale\n"
"function quantize(pitch, root, name)\n"
"  local intervals = midi.scales[name]\n"
"  if not intervals then\n"
"    error('Unknown scale: ' .. tostring(name))\n"
"  end\n"
"  return midi.quantize(pitch, root, intervals)\n"
"end\n"
"\n"
"-- Global aliases for concise syntax\n"
"-- Pitch constants as globals\n"
"for oct = 0, 8 do\n"
"  _G['c'..oct] = midi['c'..oct]\n"
"  _G['cs'..oct] = midi['cs'..oct]\n"
"  _G['d'..oct] = midi['d'..oct]\n"
"  _G['ds'..oct] = midi['ds'..oct]\n"
"  _G['e'..oct] = midi['e'..oct]\n"
"  _G['f'..oct] = midi['f'..oct]\n"
"  _G['fs'..oct] = midi['fs'..oct]\n"
"  _G['g'..oct] = midi['g'..oct]\n"
"  _G['gs'..oct] = midi['gs'..oct]\n"
"  _G['a'..oct] = midi['a'..oct]\n"
"  _G['as'..oct] = midi['as'..oct]\n"
"  _G['b'..oct] = midi['b'..oct]\n"
"  _G['db'..oct] = midi['db'..oct]\n"
"  _G['eb'..oct] = midi['eb'..oct]\n"
"  _G['gb'..oct] = midi['gb'..oct]\n"
"  _G['ab'..oct] = midi['ab'..oct]\n"
"  _G['bb'..oct] = midi['bb'..oct]\n"
"end\n"
"\n"
"-- Dynamics as globals\n"
"ppp, pp, p, mp, mf, f, ff, fff = midi.ppp, midi.pp, midi.p, midi.mp, midi.mf, midi.f, midi.ff, midi.fff\n"
"\n"
"-- Durations as globals\n"
"whole, half, quarter, eighth, sixteenth = midi.whole, midi.half, midi.quarter, midi.eighth, midi.sixteenth\n"
"\n"
"-- Chord builders as globals\n"
"major, minor, dim, aug, dom7, maj7, min7 = midi.major, midi.minor, midi.dim, midi.aug, midi.dom7, midi.maj7, midi.min7\n"
"\n"
"-- Other utilities as globals\n"
"transpose, octave_up, octave_down = midi.transpose, midi.octave_up, midi.octave_down\n"
"dotted, rest, sleep = midi.dotted, midi.rest, midi.sleep\n"
"\n"
"-- Global help function\n"
"function help() midi.help() end\n"
"\n"
"-- REPL convenience: global midi output\n"
"midi._out = nil\n"
"\n"
"function open(arg)\n"
"  if midi._out then midi._out:close() end\n"
"  midi._out = midi.open(arg)\n"
"  return midi._out\n"
"end\n"
"\n"
"function close()\n"
"  if midi._out then\n"
"    midi._out:close()\n"
"    midi._out = nil\n"
"  end\n"
"end\n"
"\n"
"function n(pitch, vel, dur, ch)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  midi._out:note(pitch, vel or midi.mf, dur or midi.quarter, ch or 1)\n"
"end\n"
"\n"
"function ch(pitches, vel, dur, channel)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  midi._out:chord(pitches, vel or midi.mf, dur or midi.quarter, channel or 1)\n"
"end\n"
"\n"
"function arp(pitches, vel, dur, channel)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  midi._out:arpeggio(pitches, vel or midi.mf, dur or midi.eighth, channel or 1)\n"
"end\n"
"\n"
"-- ============================================================================\n"
"-- Generative Music Functions\n"
"-- ============================================================================\n"
"\n"
"-- Pure PRNG using Linear Congruential Generator (same constants as glibc)\n"
"-- Returns (random_value, next_seed)\n"
"function midi.next_random(seed)\n"
"  local next_seed = (seed * 1103515245 + 12345) % 2147483648\n"
"  local value = math.floor(next_seed / 65536)  -- extract higher bits\n"
"  return value, next_seed\n"
"end\n"
"\n"
"-- Generate random int in range [lo, hi]\n"
"-- Returns (value, next_seed)\n"
"function midi.random_range(seed, lo, hi)\n"
"  if lo >= hi then return lo, seed end\n"
"  local r, next_seed = midi.next_random(seed)\n"
"  return lo + (r % (hi - lo + 1)), next_seed\n"
"end\n"
"\n"
"-- Generate n random ints in range [lo, hi]\n"
"-- Returns (list, next_seed)\n"
"function midi.random_list(seed, n, lo, hi)\n"
"  local result = {}\n"
"  local s = seed\n"
"  for i = 1, n do\n"
"    local r\n"
"    r, s = midi.random_range(s, lo, hi)\n"
"    result[i] = r\n"
"  end\n"
"  return result, s\n"
"end\n"
"\n"
"-- Euclidean rhythm using Bjorklund's algorithm\n"
"-- Returns a list of booleans where true = hit, false = rest\n"
"function midi.euclidean(hits, steps)\n"
"  if hits <= 0 then\n"
"    local result = {}\n"
"    for i = 1, steps do result[i] = false end\n"
"    return result\n"
"  end\n"
"  if hits >= steps then\n"
"    local result = {}\n"
"    for i = 1, steps do result[i] = true end\n"
"    return result\n"
"  end\n"
"\n"
"  -- Initialize sequences\n"
"  local seqs = {}\n"
"  for i = 1, hits do seqs[i] = {true} end\n"
"  local remainder = {}\n"
"  for i = 1, steps - hits do remainder[i] = {false} end\n"
"\n"
"  -- Bjorklund's algorithm\n"
"  while #remainder > 1 do\n"
"    local new_seqs = {}\n"
"    local min_len = math.min(#seqs, #remainder)\n"
"    for i = 1, min_len do\n"
"      local combined = {}\n"
"      for _, v in ipairs(seqs[i]) do combined[#combined + 1] = v end\n"
"      for _, v in ipairs(remainder[i]) do combined[#combined + 1] = v end\n"
"      new_seqs[i] = combined\n"
"    end\n"
"    local new_remainder = {}\n"
"    for i = min_len + 1, #seqs do new_remainder[#new_remainder + 1] = seqs[i] end\n"
"    for i = min_len + 1, #remainder do new_remainder[#new_remainder + 1] = remainder[i] end\n"
"    seqs = new_seqs\n"
"    remainder = new_remainder\n"
"  end\n"
"\n"
"  -- Flatten result\n"
"  local result = {}\n"
"  for _, seq in ipairs(seqs) do\n"
"    for _, v in ipairs(seq) do result[#result + 1] = v end\n"
"  end\n"
"  for _, seq in ipairs(remainder) do\n"
"    for _, v in ipairs(seq) do result[#result + 1] = v end\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Arpeggio patterns\n"
"function midi.arp_up(list)\n"
"  local result = {}\n"
"  for i, v in ipairs(list) do result[i] = v end\n"
"  return result\n"
"end\n"
"\n"
"function midi.arp_down(list)\n"
"  local result = {}\n"
"  for i = #list, 1, -1 do result[#result + 1] = list[i] end\n"
"  return result\n"
"end\n"
"\n"
"function midi.arp_up_down(list)\n"
"  if #list <= 1 then return midi.arp_up(list) end\n"
"  local result = {}\n"
"  for _, v in ipairs(list) do result[#result + 1] = v end\n"
"  for i = #list - 1, 2, -1 do result[#result + 1] = list[i] end\n"
"  return result\n"
"end\n"
"\n"
"-- Retrograde - reverse a list\n"
"function midi.retrograde(list)\n"
"  return midi.arp_down(list)\n"
"end\n"
"\n"
"-- Melodic inversion around an axis pitch\n"
"function midi.invert(list, axis)\n"
"  local result = {}\n"
"  for i, pitch in ipairs(list) do\n"
"    result[i] = 2 * axis - pitch\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Fisher-Yates shuffle using seed\n"
"function midi.shuffle(seed, list)\n"
"  local result = {}\n"
"  for i, v in ipairs(list) do result[i] = v end\n"
"  local s = seed\n"
"  for i = #result, 2, -1 do\n"
"    local j\n"
"    j, s = midi.random_range(s, 1, i)\n"
"    result[i], result[j] = result[j], result[i]\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Pick one element from a list using seed\n"
"function midi.pick(seed, list)\n"
"  if #list == 0 then return nil end\n"
"  local idx, _ = midi.random_range(seed, 1, #list)\n"
"  return list[idx]\n"
"end\n"
"\n"
"-- Pick n elements from a list (with replacement)\n"
"function midi.pick_n(seed, n, list)\n"
"  if #list == 0 then return {} end\n"
"  local result = {}\n"
"  local s = seed\n"
"  for i = 1, n do\n"
"    local idx\n"
"    idx, s = midi.random_range(s, 1, #list)\n"
"    result[i] = list[idx]\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Random walk - start from a pitch, take n steps of max size\n"
"function midi.random_walk(seed, start, max_step, n)\n"
"  local result = {}\n"
"  local s = seed\n"
"  local pitch = start\n"
"  for i = 1, n do\n"
"    result[i] = pitch\n"
"    local step\n"
"    step, s = midi.random_range(s, -max_step, max_step)\n"
"    pitch = math.max(0, math.min(127, pitch + step))\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Drunk walk constrained to scale pitches\n"
"function midi.drunk_walk(seed, start, scale_pitches, max_degrees, n)\n"
"  if #scale_pitches == 0 then return {} end\n"
"\n"
"  -- Find closest index in scale to start pitch\n"
"  local function find_closest(p, pitches)\n"
"    local best_idx = 1\n"
"    local best_dist = math.abs(p - pitches[1])\n"
"    for i = 2, #pitches do\n"
"      local dist = math.abs(p - pitches[i])\n"
"      if dist < best_dist then\n"
"        best_dist = dist\n"
"        best_idx = i\n"
"      end\n"
"    end\n"
"    return best_idx\n"
"  end\n"
"\n"
"  local result = {}\n"
"  local s = seed\n"
"  local idx = find_closest(start, scale_pitches)\n"
"\n"
"  for i = 1, n do\n"
"    result[i] = scale_pitches[idx]\n"
"    local step\n"
"    step, s = midi.random_range(s, -max_degrees, max_degrees)\n"
"    idx = math.max(1, math.min(#scale_pitches, idx + step))\n"
"  end\n"
"  return result\n"
"end\n"
"\n"
"-- Weighted random selection\n"
"-- weights is a table of {value, weight} pairs\n"
"function midi.weighted_pick(seed, weights)\n"
"  local total = 0\n"
"  for _, w in ipairs(weights) do total = total + w[2] end\n"
"  if total <= 0 then return nil end\n"
"\n"
"  local r, _ = midi.random_range(seed, 1, total)\n"
"  local cumulative = 0\n"
"  for _, w in ipairs(weights) do\n"
"    cumulative = cumulative + w[2]\n"
"    if r <= cumulative then return w[1] end\n"
"  end\n"
"  return weights[#weights][1]\n"
"end\n"
"\n"
"-- Probability gate - returns true with given probability (0-100)\n"
"function midi.chance(seed, probability)\n"
"  local r, next_seed = midi.random_range(seed, 0, 99)\n"
"  return r < probability, next_seed\n"
"end\n"
"\n"
"-- Global aliases for generative functions\n"
"next_random = midi.next_random\n"
"random_range = midi.random_range\n"
"random_list = midi.random_list\n"
"euclidean = midi.euclidean\n"
"arp_up = midi.arp_up\n"
"arp_down = midi.arp_down\n"
"arp_up_down = midi.arp_up_down\n"
"retrograde = midi.retrograde\n"
"invert = midi.invert\n"
"shuffle = midi.shuffle\n"
"pick = midi.pick\n"
"pick_n = midi.pick_n\n"
"random_walk = midi.random_walk\n"
"drunk_walk = midi.drunk_walk\n"
"weighted_pick = midi.weighted_pick\n"
"chance = midi.chance\n"
"\n"
"-- ============================================================================\n"
"-- Async Scheduler Convenience Functions\n"
"-- ============================================================================\n"
"\n"
"-- Global aliases for scheduler functions\n"
"spawn = scheduler.spawn\n"
"yield_ms = scheduler.yield_ms\n"
"run = scheduler.run\n"
"stop = scheduler.stop\n"
"voices = scheduler.voices\n"
"\n"
"-- Play a note asynchronously (for use inside spawned voices)\n"
"-- Uses yield_ms so other voices can run during the note duration\n"
"function play(pitch, vel, dur, ch)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  local m = midi._out\n"
"  local velocity = vel or midi.mf\n"
"  local duration = dur or midi.quarter\n"
"  local channel = ch or 1\n"
"  m:note_on(pitch, velocity, channel)\n"
"  yield_ms(duration)\n"
"  m:note_off(pitch, channel)\n"
"end\n"
"\n"
"-- Play a chord asynchronously (for use inside spawned voices)\n"
"function play_chord(pitches, vel, dur, ch)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  local m = midi._out\n"
"  local velocity = vel or midi.mf\n"
"  local duration = dur or midi.quarter\n"
"  local channel = ch or 1\n"
"  for _, pitch in ipairs(pitches) do\n"
"    m:note_on(pitch, velocity, channel)\n"
"  end\n"
"  yield_ms(duration)\n"
"  for _, pitch in ipairs(pitches) do\n"
"    m:note_off(pitch, channel)\n"
"  end\n"
"end\n"
"\n"
"-- Play an arpeggio asynchronously (for use inside spawned voices)\n"
"function play_arp(pitches, vel, dur, ch)\n"
"  if not midi._out then error('No MIDI port open. Use open() first.') end\n"
"  local m = midi._out\n"
"  local velocity = vel or midi.mf\n"
"  local duration = dur or midi.eighth\n"
"  local channel = ch or 1\n"
"  for _, pitch in ipairs(pitches) do\n"
"    m:note_on(pitch, velocity, channel)\n"
"    yield_ms(duration)\n"
"    m:note_off(pitch, channel)\n"
"  end\n"
"end\n";
