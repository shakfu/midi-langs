/* recording.c - Recording and capture system for MIDI Forth interpreter */

#include "forth_midi.h"
#include "midi_file.h"

/* All globals now accessed via g_ctx macros defined in forth_midi.h */

/* Get current time in milliseconds since capture start */
static uint32_t capture_get_time_ms(void) {
    struct timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    uint32_t elapsed = (now.tv_sec - capture_start_time.tv_sec) * 1000 +
                       (now.tv_nsec - capture_start_time.tv_nsec) / 1000000;
    return elapsed;
}

/* Add an event to the capture buffer (called from MIDI send functions) */
void capture_add_event(int type, int channel, int data1, int data2) {
    if (!capture_active) return;
    if (capture_count >= MAX_CAPTURE_EVENTS) {
        printf("Capture buffer full!\n");
        capture_active = 0;
        return;
    }
    CapturedEvent* e = &capture_buffer[capture_count++];
    e->time_ms = capture_get_time_ms();
    e->type = type;
    e->channel = channel;
    e->data1 = data1;
    e->data2 = data2;
}

/* rec ( -- ) Start recording input commands */
void op_rec_start(Stack* s) {
    (void)stack;
    if (recording_active) {
        printf("Already recording (use 'stop' first)\n");
        return;
    }
    /* Clear any previous recording */
    for (int i = 0; i < recording_count; i++) {
        free(recording_buffer[i]);
        recording_buffer[i] = NULL;
    }
    recording_count = 0;
    recording_active = 1;
    printf("Recording started. Use 'stop' to end, 'save filename' to save.\n");
}

/* stop ( -- ) Stop recording */
void op_rec_stop(Stack* s) {
    (void)stack;
    if (!recording_active) {
        printf("Not recording\n");
        return;
    }
    recording_active = 0;
    printf("Recording stopped. %d lines captured. Use 'save filename' to save.\n", recording_count);
}

/* save ( filename -- ) Save recording to file (handled in interpreter) */
void op_rec_save(Stack* s) {
    (void)stack;
    /* This is a no-op - save is handled specially in the interpreter
       because it needs the filename as a string token */
}

/* Add a line to the recording buffer */
void recording_add_line(const char* line) {
    if (!recording_active) return;
    if (recording_count >= MAX_RECORDING_LINES) {
        printf("Recording buffer full!\n");
        recording_active = 0;
        return;
    }
    recording_buffer[recording_count] = strdup(line);
    recording_count++;
}

/* Save recording to file */
int recording_save(const char* filename) {
    if (recording_count == 0) {
        printf("Nothing to save (recording is empty)\n");
        return -1;
    }

    FILE* f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error: cannot create file '%s'\n", filename);
        return -1;
    }

    /* Write header comment */
    fprintf(f, "\\ MIDI Forth recording\n");
    fprintf(f, "\\ Generated by midi_forth\n\n");

    /* Write all recorded lines */
    for (int i = 0; i < recording_count; i++) {
        fprintf(f, "%s\n", recording_buffer[i]);
    }

    fclose(f);
    printf("Saved %d lines to '%s'\n", recording_count, filename);
    return 0;
}

/* Clear recording buffer */
void recording_clear(void) {
    for (int i = 0; i < recording_count; i++) {
        free(recording_buffer[i]);
        recording_buffer[i] = NULL;
    }
    recording_count = 0;
    recording_active = 0;
}

/* rec-midi ( -- ) Start recording MIDI events */
void op_capture_start(Stack* s) {
    (void)stack;
    if (capture_active) {
        printf("Already recording (use 'stop' first)\n");
        return;
    }
    capture_count = 0;
    capture_active = 1;
    clock_gettime(CLOCK_MONOTONIC, &capture_start_time);
    printf("MIDI recording started. Play notes, then 'stop' and 'save-midi filename'.\n");
}

/* stop ( -- ) Stop recording (also called by op_rec_stop) */
void op_capture_stop(Stack* s) {
    (void)stack;
    if (!capture_active) {
        return;  /* Silent if not recording */
    }
    capture_active = 0;
    printf("MIDI recording stopped. %d events recorded. Use 'save-midi filename' to save.\n", capture_count);
}

/* save-midi ( filename -- ) Save captured MIDI to file (handled in interpreter) */
void op_save_midi(Stack* s) {
    (void)stack;
    /* This is a no-op - save-midi is handled specially in the interpreter */
}

/* Helper: pitch number to note name */
static const char* pitch_to_name(int pitch) {
    static char buf[8];
    static const char* names[] = {"c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"};
    int octave = (pitch / 12) - 1;
    int note = pitch % 12;
    snprintf(buf, sizeof(buf), "%s%d", names[note], octave);
    return buf;
}

/* Save captured MIDI to file as Forth sequence commands */
int capture_save_midi(const char* filename) {
    if (capture_count == 0) {
        printf("Nothing to save (recording is empty)\n");
        return -1;
    }

    FILE* f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error: cannot create file '%s'\n", filename);
        return -1;
    }

    /* Write header */
    fprintf(f, "\\ MIDI recording\n");
    fprintf(f, "\\ %d events recorded\n\n", capture_count);
    fprintf(f, "\\ Tempo: %d BPM\n", global_bpm);
    fprintf(f, "%d bpm!\n\n", global_bpm);
    fprintf(f, "0 seq-start\n\n");

    /* Track note-on events to pair with note-offs */
    int note_on_time[16][128];
    int note_on_vel[16][128];
    for (int ch = 0; ch < 16; ch++) {
        for (int p = 0; p < 128; p++) {
            note_on_time[ch][p] = -1;
            note_on_vel[ch][p] = 0;
        }
    }

    /* Build list of complete notes */
    typedef struct { int time_ms; int pitch; int vel; int dur_ms; int ch; } Note;
    Note notes[MAX_CAPTURE_EVENTS];
    int note_count = 0;

    for (int i = 0; i < capture_count; i++) {
        CapturedEvent* e = &capture_buffer[i];

        if (e->type == 0) {  /* Note-on */
            note_on_time[e->channel][e->data1] = e->time_ms;
            note_on_vel[e->channel][e->data1] = e->data2;
        } else if (e->type == 1) {  /* Note-off */
            int start_ms = note_on_time[e->channel][e->data1];
            if (start_ms >= 0 && note_count < MAX_CAPTURE_EVENTS) {
                notes[note_count].time_ms = start_ms;
                notes[note_count].pitch = e->data1;
                notes[note_count].vel = note_on_vel[e->channel][e->data1];
                notes[note_count].dur_ms = e->time_ms - start_ms;
                notes[note_count].ch = e->channel + 1;
                note_count++;
                note_on_time[e->channel][e->data1] = -1;
            }
        }
    }

    /* Sort notes by time (simple insertion sort) */
    for (int i = 1; i < note_count; i++) {
        Note tmp = notes[i];
        int j = i - 1;
        while (j >= 0 && notes[j].time_ms > tmp.time_ms) {
            notes[j + 1] = notes[j];
            j--;
        }
        notes[j + 1] = tmp;
    }

    /* Output notes using new syntax */
    int last_vel = -1;
    int last_dur = -1;
    int last_ch = -1;

    for (int i = 0; i < note_count; i++) {
        Note* n = &notes[i];
        int dur_ms = n->dur_ms;
        if (dur_ms < 1) dur_ms = 1;

        /* Set parameters if changed */
        if (n->ch != last_ch) {
            fprintf(f, "%d ch! ", n->ch);
            last_ch = n->ch;
        }
        if (n->vel != last_vel) {
            fprintf(f, "%d vel! ", n->vel);
            last_vel = n->vel;
        }
        if (dur_ms != last_dur) {
            fprintf(f, "%d dur! ", dur_ms);
            last_dur = dur_ms;
        }

        /* Output note */
        fprintf(f, "%s,\n", pitch_to_name(n->pitch));
    }

    fprintf(f, "\n0 seq-end\n");
    fprintf(f, "\n\\ %d notes exported\n", note_count);
    fprintf(f, "\\ To play: midi-open 0 seq seq-play midi-close\n");

    fclose(f);
    printf("Saved %d notes to '%s'\n", note_count, filename);
    return 0;
}

/* Clear capture buffer */
void capture_clear(void) {
    capture_count = 0;
    capture_active = 0;
}

/* ============================================================================
 * Standard MIDI File I/O
 * ============================================================================ */

/* write-mid ( filename -- ) Write captured events to standard MIDI file */
int capture_write_mid(const char* filename) {
    if (capture_count == 0) {
        printf("Nothing to save (recording is empty)\n");
        return -1;
    }

    int ppqn = TICKS_PER_QUARTER;

    /* Create MIDI file writer */
    midi_file_writer* writer = NULL;
    if (midi_file_writer_new(&writer) != 0) {
        printf("Error: cannot create MIDI file writer\n");
        return -1;
    }

    /* Set PPQN and add a track for events */
    midi_file_writer_set_ppqn(writer, ppqn);
    midi_file_writer_add_track(writer);

    /* Add tempo meta event (set tempo in microseconds per quarter note) */
    int us_per_beat = 60000000 / global_bpm;
    midi_file_writer_tempo(writer, 0, 0, us_per_beat);

    /* Convert captured events to MIDI file events */
    for (int i = 0; i < capture_count; i++) {
        CapturedEvent* e = &capture_buffer[i];
        int tick = (e->time_ms * global_bpm * ppqn) / 60000;

        if (e->type == EVT_NOTE_ON) {
            /* Note-on with velocity > 0 */
            midi_file_writer_note_on(writer, tick, 0, e->channel + 1, e->data1, e->data2);
        } else if (e->type == EVT_NOTE_OFF) {
            /* Note-off */
            midi_file_writer_note_off(writer, tick, 0, e->channel + 1, e->data1, 0);
        } else if (e->type == EVT_CC) {
            /* Control change */
            midi_file_writer_cc(writer, tick, 0, e->channel + 1, e->data1, e->data2);
        }
    }

    /* Write to file */
    int result = midi_file_writer_save(writer, filename);
    midi_file_writer_free(writer);

    if (result != 0) {
        printf("Error: failed to write MIDI file '%s'\n", filename);
        return -1;
    }

    printf("Saved %d events to '%s'\n", capture_count, filename);
    return 0;
}

/* Callback for reading MIDI file events */
static void read_mid_callback(void* ctx, const midi_file_event* event) {
    (void)ctx;

    /* Filter meta events for tempo display */
    if (event->type == 0x51) {
        /* Tempo meta event */
        printf("  tempo: %d us/beat (%d BPM)\n",
               event->data1, 60000000 / event->data1);
        return;
    }

    /* Only show channel events */
    if (event->type < 0x80 || event->type >= 0xF0) return;

    int status = event->type & 0xF0;
    const char* type_name = "unknown";
    switch (status) {
        case 0x80: type_name = "note-off"; break;
        case 0x90: type_name = (event->data2 > 0) ? "note-on" : "note-off"; break;
        case 0xA0: type_name = "aftertouch"; break;
        case 0xB0: type_name = "cc"; break;
        case 0xC0: type_name = "program"; break;
        case 0xD0: type_name = "ch-pressure"; break;
        case 0xE0: type_name = "pitch-bend"; break;
        default: break;
    }

    printf("  t=%5d ch=%2d %-10s %3d %3d\n",
           event->tick, event->channel + 1, type_name, event->data1, event->data2);
}

/* read-mid ( filename -- ) Read MIDI file and display info */
int capture_read_mid(const char* filename) {
    midi_file_reader* reader = NULL;
    if (midi_file_reader_new(&reader) != 0) {
        printf("Error: cannot create MIDI file reader\n");
        return -1;
    }

    int result = midi_file_reader_load(reader, filename);
    if (result == 0) {
        midi_file_reader_free(reader);
        printf("Error: cannot read MIDI file '%s'\n", filename);
        return -1;
    }

    /* Display file info */
    int num_tracks = midi_file_reader_num_tracks(reader);
    float ppqn = midi_file_reader_ppqn(reader);
    float tempo = midi_file_reader_tempo(reader);
    float duration = midi_file_reader_duration(reader);
    int format = midi_file_reader_format(reader);

    printf("MIDI file: %s\n", filename);
    printf("  format: %d\n", format);
    printf("  tracks: %d\n", num_tracks);
    printf("  ppqn: %.0f\n", ppqn);
    printf("  tempo: %.0f us/beat (%.0f BPM)\n", tempo, 60000000.0 / tempo);
    printf("  duration: %.0f ms\n", duration);
    printf("Events:\n");

    /* Display events */
    midi_file_reader_for_each(reader, NULL, read_mid_callback);

    midi_file_reader_free(reader);
    return 0;
}

/* Stack operations for MIDI file I/O */
void op_write_mid(Stack* s) {
    (void)stack;
    /* This is a no-op - write-mid is handled specially in the interpreter */
}

void op_read_mid(Stack* s) {
    (void)stack;
    /* This is a no-op - read-mid is handled specially in the interpreter */
}
