/* recording.c - Recording and capture system for MIDI Forth interpreter */

#include "forth_midi.h"

/* Recording globals - defined here */
char* recording_buffer[MAX_RECORDING_LINES];
int recording_count = 0;
int recording_active = 0;

/* MIDI capture globals - defined here */
CapturedEvent capture_buffer[MAX_CAPTURE_EVENTS];
int capture_count = 0;
int capture_active = 0;
struct timespec capture_start_time;

/* Get current time in milliseconds since capture start */
static uint32_t capture_get_time_ms(void) {
    struct timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    uint32_t elapsed = (now.tv_sec - capture_start_time.tv_sec) * 1000 +
                       (now.tv_nsec - capture_start_time.tv_nsec) / 1000000;
    return elapsed;
}

/* Add an event to the capture buffer (called from MIDI send functions) */
void capture_add_event(int type, int channel, int data1, int data2) {
    if (!capture_active) return;
    if (capture_count >= MAX_CAPTURE_EVENTS) {
        printf("Capture buffer full!\n");
        capture_active = 0;
        return;
    }
    CapturedEvent* e = &capture_buffer[capture_count++];
    e->time_ms = capture_get_time_ms();
    e->type = type;
    e->channel = channel;
    e->data1 = data1;
    e->data2 = data2;
}

/* rec ( -- ) Start recording input commands */
void op_rec_start(Stack* stack) {
    (void)stack;
    if (recording_active) {
        printf("Already recording (use 'stop' first)\n");
        return;
    }
    /* Clear any previous recording */
    for (int i = 0; i < recording_count; i++) {
        free(recording_buffer[i]);
        recording_buffer[i] = NULL;
    }
    recording_count = 0;
    recording_active = 1;
    printf("Recording started. Use 'stop' to end, 'save filename' to save.\n");
}

/* stop ( -- ) Stop recording */
void op_rec_stop(Stack* stack) {
    (void)stack;
    if (!recording_active) {
        printf("Not recording\n");
        return;
    }
    recording_active = 0;
    printf("Recording stopped. %d lines captured. Use 'save filename' to save.\n", recording_count);
}

/* save ( filename -- ) Save recording to file (handled in interpreter) */
void op_rec_save(Stack* stack) {
    (void)stack;
    /* This is a no-op - save is handled specially in the interpreter
       because it needs the filename as a string token */
}

/* Add a line to the recording buffer */
void recording_add_line(const char* line) {
    if (!recording_active) return;
    if (recording_count >= MAX_RECORDING_LINES) {
        printf("Recording buffer full!\n");
        recording_active = 0;
        return;
    }
    recording_buffer[recording_count] = strdup(line);
    recording_count++;
}

/* Save recording to file */
int recording_save(const char* filename) {
    if (recording_count == 0) {
        printf("Nothing to save (recording is empty)\n");
        return -1;
    }

    FILE* f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error: cannot create file '%s'\n", filename);
        return -1;
    }

    /* Write header comment */
    fprintf(f, "\\ MIDI Forth recording\n");
    fprintf(f, "\\ Generated by midi_forth\n\n");

    /* Write all recorded lines */
    for (int i = 0; i < recording_count; i++) {
        fprintf(f, "%s\n", recording_buffer[i]);
    }

    fclose(f);
    printf("Saved %d lines to '%s'\n", recording_count, filename);
    return 0;
}

/* Clear recording buffer */
void recording_clear(void) {
    for (int i = 0; i < recording_count; i++) {
        free(recording_buffer[i]);
        recording_buffer[i] = NULL;
    }
    recording_count = 0;
    recording_active = 0;
}

/* rec-midi ( -- ) Start recording MIDI events */
void op_capture_start(Stack* stack) {
    (void)stack;
    if (capture_active) {
        printf("Already recording (use 'stop' first)\n");
        return;
    }
    capture_count = 0;
    capture_active = 1;
    clock_gettime(CLOCK_MONOTONIC, &capture_start_time);
    printf("MIDI recording started. Play notes, then 'stop' and 'save-midi filename'.\n");
}

/* stop ( -- ) Stop recording (also called by op_rec_stop) */
void op_capture_stop(Stack* stack) {
    (void)stack;
    if (!capture_active) {
        return;  /* Silent if not recording */
    }
    capture_active = 0;
    printf("MIDI recording stopped. %d events recorded. Use 'save-midi filename' to save.\n", capture_count);
}

/* save-midi ( filename -- ) Save captured MIDI to file (handled in interpreter) */
void op_save_midi(Stack* stack) {
    (void)stack;
    /* This is a no-op - save-midi is handled specially in the interpreter */
}

/* Save captured MIDI to file as Forth sequence commands */
int capture_save_midi(const char* filename) {
    if (capture_count == 0) {
        printf("Nothing to save (recording is empty)\n");
        return -1;
    }

    FILE* f = fopen(filename, "w");
    if (f == NULL) {
        printf("Error: cannot create file '%s'\n", filename);
        return -1;
    }

    /* Write header */
    fprintf(f, "\\ MIDI recording\n");
    fprintf(f, "\\ %d events recorded\n\n", capture_count);
    fprintf(f, "\\ Tempo: %d BPM\n", global_bpm);
    fprintf(f, "%d bpm!\n\n", global_bpm);
    fprintf(f, "seq-new drop\n\n");

    /* Track note-on events to pair with note-offs */
    int note_on_time[16][128];
    for (int ch = 0; ch < 16; ch++) {
        for (int p = 0; p < 128; p++) {
            note_on_time[ch][p] = -1;
        }
    }

    int notes_written = 0;

    for (int i = 0; i < capture_count; i++) {
        CapturedEvent* e = &capture_buffer[i];

        if (e->type == 0) {  /* Note-on */
            note_on_time[e->channel][e->data1] = e->time_ms;
        } else if (e->type == 1) {  /* Note-off */
            int start_ms = note_on_time[e->channel][e->data1];
            if (start_ms >= 0) {
                int dur_ms = e->time_ms - start_ms;
                int start_ticks = (start_ms * global_bpm * TICKS_PER_QUARTER) / 60000;
                int dur_ticks = (dur_ms * global_bpm * TICKS_PER_QUARTER) / 60000;
                if (dur_ticks < 1) dur_ticks = 1;

                /* Find the velocity from the note-on event */
                int vel = 100;
                for (int j = 0; j < i; j++) {
                    if (capture_buffer[j].type == 0 &&
                        capture_buffer[j].channel == e->channel &&
                        capture_buffer[j].data1 == e->data1 &&
                        (int)capture_buffer[j].time_ms == start_ms) {
                        vel = capture_buffer[j].data2;
                        break;
                    }
                }

                fprintf(f, "%d %d %d %d %d seq-note-ch\n",
                        start_ticks, e->channel + 1, e->data1, vel, dur_ticks);
                notes_written++;

                note_on_time[e->channel][e->data1] = -1;
            }
        } else if (e->type == 2) {  /* CC */
            int time_ticks = (e->time_ms * global_bpm * TICKS_PER_QUARTER) / 60000;
            fprintf(f, "\\ t=%d CC ch=%d cc=%d val=%d\n",
                    time_ticks, e->channel + 1, e->data1, e->data2);
        }
    }

    fprintf(f, "\n\\ %d notes written\n", notes_written);
    fprintf(f, "\\ To play: midi-open seq-play midi-close\n");

    fclose(f);
    printf("Saved %d notes to '%s'\n", notes_written, filename);
    return 0;
}

/* Clear capture buffer */
void capture_clear(void) {
    capture_count = 0;
    capture_active = 0;
}
