#!/usr/bin/env python3
"""
Convert Haskell library files to C header with embedded strings.

Usage: embed_libs.py <output.h> <libdir1> [libdir2 ...]

Example:
    embed_libs.py build/mhs_embedded_libs.h thirdparty/MicroHs/lib projects/mhs-midi/lib
"""

import argparse
import os
import sys
from pathlib import Path


def escape_c_string(content: bytes) -> str:
    """Escape raw bytes for C string literal.

    Takes bytes, not str, to properly handle UTF-8 byte sequences.
    Each byte is escaped individually to produce valid C octal escapes.
    """
    result = []
    for byte in content:
        if byte == ord('\\'):
            result.append('\\\\')
        elif byte == ord('"'):
            result.append('\\"')
        elif byte == ord('\n'):
            result.append('\\n')
        elif byte == ord('\r'):
            result.append('\\r')
        elif byte == ord('\t'):
            result.append('\\t')
        elif byte < 32 or byte > 126:
            # Non-printable or non-ASCII: use octal escape (max 3 digits, 0-255)
            result.append(f'\\{byte:03o}')
        else:
            result.append(chr(byte))
    return ''.join(result)


def split_string_literal(escaped: str, max_len: int = 4000) -> list[str]:
    """
    Split a long string into multiple literals to avoid compiler limits.
    C89 requires at least 509 chars, C99 requires 4095.
    We split conservatively to handle escape sequences.
    """
    if len(escaped) <= max_len:
        return [escaped]

    chunks = []
    current = []
    current_len = 0

    i = 0
    while i < len(escaped):
        # Handle escape sequences as atomic units
        if escaped[i] == '\\' and i + 1 < len(escaped):
            if escaped[i + 1] in '\\"\'\n\r\t':
                seq = escaped[i:i + 2]
                i += 2
            elif escaped[i + 1].isdigit():
                # Octal escape: up to 3 digits
                end = i + 2
                while end < len(escaped) and end < i + 4 and escaped[end].isdigit():
                    end += 1
                seq = escaped[i:end]
                i = end
            else:
                seq = escaped[i:i + 2]
                i += 2
        else:
            seq = escaped[i]
            i += 1

        if current_len + len(seq) > max_len:
            chunks.append(''.join(current))
            current = [seq]
            current_len = len(seq)
        else:
            current.append(seq)
            current_len += len(seq)

    if current:
        chunks.append(''.join(current))

    return chunks


def collect_files(lib_dirs: list[str]) -> list[tuple[str, str, bytes]]:
    """
    Collect all .hs files from library directories.
    Returns list of (vfs_path, full_path, content_bytes).
    """
    files = []
    seen_paths = set()

    for lib_dir in lib_dirs:
        lib_path = Path(lib_dir).resolve()
        if not lib_path.exists():
            print(f"Warning: Library directory not found: {lib_dir}", file=sys.stderr)
            continue

        # Determine the base name for VFS paths
        # e.g., thirdparty/MicroHs/lib -> lib/
        # e.g., projects/mhs-midi/lib -> lib/
        base_name = lib_path.name  # "lib"

        # Include both .hs and .hs-boot files
        for pattern in ["*.hs", "*.hs-boot"]:
          for hs_file in lib_path.rglob(pattern):
            # Create VFS path: lib/Module/Name.hs
            rel_path = hs_file.relative_to(lib_path)
            vfs_path = f"{base_name}/{rel_path}"

            # Skip duplicates (MIDI lib might override stdlib)
            if vfs_path in seen_paths:
                print(f"Note: Skipping duplicate {vfs_path} from {hs_file}", file=sys.stderr)
                continue
            seen_paths.add(vfs_path)

            try:
                # Read as bytes to preserve exact file content
                content = hs_file.read_bytes()
                files.append((vfs_path, str(hs_file), content))
            except Exception as e:
                print(f"Warning: Could not read {hs_file}: {e}", file=sys.stderr)

    return files


def generate_header(output_path: str, lib_dirs: list[str]) -> None:
    """Generate C header with all embedded files."""
    files = collect_files(lib_dirs)

    if not files:
        print("Error: No .hs files found in specified directories", file=sys.stderr)
        sys.exit(1)

    total_size = sum(len(content) for _, _, content in files)
    print(f"Embedding {len(files)} files ({total_size:,} bytes total)")

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("/* Auto-generated by embed_libs.py - DO NOT EDIT */\n")
        f.write(f"/* {len(files)} embedded Haskell library files */\n\n")
        f.write("#ifndef MHS_EMBEDDED_LIBS_H\n")
        f.write("#define MHS_EMBEDDED_LIBS_H\n\n")
        f.write("#include <stddef.h>\n\n")

        f.write("typedef struct {\n")
        f.write("    const char* path;      /* VFS path, e.g., \"lib/Prelude.hs\" */\n")
        f.write("    const char* content;   /* File contents */\n")
        f.write("    size_t length;         /* Content length in bytes */\n")
        f.write("} EmbeddedFile;\n\n")

        f.write("static const EmbeddedFile embedded_files[] = {\n")

        for vfs_path, full_path, content in sorted(files):
            escaped = escape_c_string(content)
            chunks = split_string_literal(escaped)

            f.write(f"    /* {full_path} */\n")
            f.write(f'    {{ "{vfs_path}",\n')

            if len(chunks) == 1:
                f.write(f'      "{chunks[0]}",\n')
            else:
                # Multiple chunks need concatenation
                f.write('      ')
                for i, chunk in enumerate(chunks):
                    if i > 0:
                        f.write('\n      ')
                    f.write(f'"{chunk}"')
                f.write(',\n')

            f.write(f'      {len(content)} }},\n\n')

        f.write("    /* Sentinel */\n")
        f.write("    { NULL, NULL, 0 }\n")
        f.write("};\n\n")

        f.write(f"#define EMBEDDED_FILE_COUNT {len(files)}\n\n")
        f.write("#endif /* MHS_EMBEDDED_LIBS_H */\n")

    print(f"Generated: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Convert Haskell library files to C header with embedded strings"
    )
    parser.add_argument(
        "output",
        help="Output header file path"
    )
    parser.add_argument(
        "libdirs",
        nargs="+",
        help="Library directories to embed (e.g., thirdparty/MicroHs/lib)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Print each file being processed"
    )

    args = parser.parse_args()

    # Ensure output directory exists
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    generate_header(args.output, args.libdirs)


if __name__ == "__main__":
    main()
